'''
리스트 자료형 - 배열 자료구조, Linked List 자료구조로 되어 있음
'''
a = [1,2,3,4,5,6,7,8,9]
print(a)

#idx=4 (다섯번째 element)에 접근하려면
print(a[4]) #5

#빈 리스트 선언 방법1
a = list()
print(a) #[]

#빈 리스트 선언 방법1
a = []
print(a) #[]

#크기가 N이고 모든 값이 0인 1차원 리스트로 초기화
n = 10
a = [0] * n 
print(a) # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

#리스트 인덱싱 : 특정 인덱스의 원소에 접근하는 것, 음수로 접근시 거꾸로 탐색
a = [1,2,3,4,5,6,7,8,9]
print(a[-1]) #9 :뒤에서 1st
print(a[-3]) #7 :뒤에서 3th

#원소 값 변경
a[3] = 7
print(a) # [1,2,3,7,...]

#리스트 슬라이싱 : 연속적인 위치를 갖는 원소들을 가져와야 할 때 -> 원본은 그대로!
# 두 번째 원소부터 네 번째 원소까지의 모든 데이터를 갖는 리스트를 가져오고 싶을 때
# [시작idx, 끝idx] 끝idx는 미포함
print(a[1:4]) #[2, 3, 7]
print(a) #[1, 2, 3, 7, 5, 6, 7, 8, 9]

#리스트 컴프리헨션 : 리스트 초기화 방법 중 하나 (중요!)
#0~19까지의 수 중 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 == 1]
print(array) #[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

#일반적인 코드
array = []
for i in range(20):
    if i % 2 == 1:
        array.append(i)

print(array)

#1~9까지 수의 제곱 값을 포함하는 리스트
array = [i * i for i in range(1,10)] #range(시작값,끝값) 끝값 미포함
print(array) #[1, 4, 9, 16, 25, 36, 49, 64, 81]

# M by M 2차원 리스트 초기화
n = 3
m = 3
array = [[0] * m for _ in range(n) ] #row내부먼저 m초기화 한 걸 n번 반복
print(array) #[[0, 0, 0], [0, 0, 0], [0, 0, 0]]

# 3x4 리스트(행렬)
n = 3
m = 4
array = [[0] * m for _ in range(n)]
print(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]


#(실수주의) 잘못된 방법 3x4행렬
n = 3
m = 4
array = [[0] * m] * n
print(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
array[1][1] = 5
print(array) # [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]
#의도와 달리 3개의 리스트에서 idx=1에 해당하는 값이 5로 변경됨 => 얉은복사로 생성되서

#리스트 메서드들
a = [1,4,3]

#원소 삽입 O(1)
a.append(2)
print("삽입: ",a) # [1, 4, 3, 2]

#오름차순 정렬 O(NlogN)
a.sort() 
print("오름차순 정렬: ", a) #[1, 2, 3, 4] => 원본이 변경


#내림차순 정렬 O(NlogN)
a.sort(reverse=True)
print("내림차순 정렬: ", a) #[4, 3, 2, 1]

#리스트 원소 순서 뒤집기 O(N)
a.reverse()
print("리스트 원소 순서 변경 :",a) #[1, 2, 3, 4]

#특정 인덱스에 데이터 추가 O(N)
a.insert(2,3)
print("2번째 인덱스에 3 추가 ",a) #[1,2,3,3,4]

#리스트에서 특정한 값을 가지는 데이트 개수 카운트 O(N)
print("a리스트에 들어있는 3의 개수: ",a.count(3)) # 2

#특정한 값을 갖는 원소 제거, 여러개면 idx앞족에 있는 값 제거 O(N)
a.remove(3)
print("데이터 3 제거 : ", a) #[1, 2, 4]

a.append(1)
print(a) # [1, 2, 4, 1]

a.remove(1)
print(a) # [2, 4, 1]

# insert(), remove() 의 경우 특정 인덱스에 값을 추가하거나 삭제 => O(N)
# 해당 자리에 값을 추가/삭제 후 나머지 요소들을 자리 조정해줘야 함! 사용에 주의하자
# append()의 경우 맨 뒤에 추가라 O(1)

#특정 값의 원소를 모두 제거해야 할 경우
#리스트에서 3,5 라는 데이터를 모두 지우고 싶을 때 
a = [1,2,3,4,5,5,5]
remove_set = {3,5}
# i가 remove_set에 없으면 result 리스트에 넣어라
result = [i for i in a if i not in remove_set] 
print(result) #[1, 2, 4]

#리스트에서 첫번쨰 원소가 remove_set에 있는지 확인하는게 O(1), n 개의 요소 확인 -> O(N)
#컴프리헨션 대신 remove() 사용시 O(N)을 n번 반복하니 O(N^2)

#리스트 곱셈
a = [1,2,3]
b = a * 3
print(b) #[1, 2, 3, 1, 2, 3, 1, 2, 3]
b[5] = 8
print(b) #[1, 2, 3, 1, 2, 8, 1, 2, 3]

#같은 원소가 여러 개 있는 리스트 만들 때 -> 1차 리스트는 이 방식 ok 2차원 리스트는 ㄴㄴ
a = [0] * 10
print(a) #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
a[5] = 5
print(a) #[0, 0, 0, 0, 0, 5, 0, 0, 0, 0]

#슬라이싱
a = [10, 20, 30, 40, 50]
#    0   1   2   3   4
#    -5  -4  -3  -2  -1

print(a[2:4]) #[30,40] 원본은 유지
print(a) #[10, 20, 30, 40, 50]
print(a[2:-1]) #[30,40]

print(a[1:4:2]) # 2step으로 잘라라 =>  [20, 40]
print(a[-5:-2:2]) #[10, 30]
print(a[::-1]) #[50, 40, 30, 20, 10] #리스트 뒤집을 때 많이 사용

#[20,30,40] 고른다음 역순해서 [40,30,20] 아닌가 했는데 아님!
#포인터라고 생각하자, 포인터가 오른쪽에서 접근하는데 1부터 4는 불가능! 그래서 [] 빈 리스트
print(a[1:4:-1]) # -1 step = 역순으로 요소를 선택해라! 
print(a[4:1:-1]) # 포인터가 <- 방향으로 가는데 시작이4 끝이 1(미포함이니까 2까지) => [50,40,30]

#list.pop() 맨 뒤 원소 꺼냄 ,  list.pop(idx) 해당 인덱스 원소 제거
a = [10, 20, 30, 40, 50]
a.pop(2)
print(a) #[10, 20, 40, 50]